## This is a generated Tcl script containing edit commands
##
## Generated by: Formality U-2022.12-SP6
## Date: Tue Mar 25 00:01:09 2025
##

##
## You can 'source' this file in Formality (R), Formality (R) ECO, Design Compiler (R),
## IC Compiler (TM), IC Compiler II (TM), or Fusion Compiler (TM).
##


# Set fm_edit_enable_warnings to 1 to print warnings, or set it to 0 to hide warnings.

global fm_edit_enable_warnings
set fm_edit_enable_warnings 1

global synopsys_program_name

if { $synopsys_program_name eq "fm_shell" } {

    # Set fm_edit_substitute_container to apply edit commands from
    # one container to another container. For example, set to "i" to
    # make all edit commands apply to the "i" container.

    global fm_edit_substitute_container
    #    set fm_edit_substitute_container "i"


    # Use fm_edit_echo_commands to echo ECO commands to stdout (if 1)
    # or execute ECO commands (if 0 or not set)

    global fm_edit_echo_commands
    #    set fm_edit_echo_commands 1


    # Use fm_edit_use_edit_libraries to do the edits in edit (sandbox)
    # libraries (if set to 1), or directly in the main (non-edit)
    # libraries (if 0 or not set)

    global fm_edit_use_edit_libraries
    #    set fm_edit_use_edit_libraries 1
}

if { $synopsys_program_name eq "dc_shell" } {

    # Set fm_edit_substitute_library to apply edit commands from
    # one library to another library. For example, set to "*" to
    # make all edit commands use a wildcard for the library name.

    global fm_edit_substitute_library
    #    set fm_edit_substitute_library "*"
}

if { $synopsys_program_name eq "icc_shell" } {

    # Set fm_edit_substitute_library to apply edit commands from
    # one library to another library. For example, set to "*" to
    # make all edit commands use a wildcard for the library name.

    global fm_edit_substitute_library
    #    set fm_edit_substitute_library "*"


    # Set fm_edit_root_path to the top of the design hierarchy that is
    # being worked on. Use this if you are working on a part of the
    # overall design. Leave unset if you are working on the entire
    # design.

    global fm_edit_root_path
    #    set fm_edit_root_path "top/cell1/cell2"
}

if { $synopsys_program_name eq "icc2_shell" } {

    # Set fm_edit_substitute_library to apply edit commands from
    # one library to another library. For example, set to "*" to
    # make all edit commands use a wildcard for the library name.

    global fm_edit_substitute_library
    #    set fm_edit_substitute_library "*"


    # Set fm_edit_root_path to the top of the design hierarchy that is
    # being worked on. Use this if you are working on a part of the
    # overall design. Leave unset if you are working on the entire
    # design.

    global fm_edit_root_path
    #    set fm_edit_root_path "top/cell1/cell2"
}

if { $synopsys_program_name eq "fc_shell" } {

    # Set fm_edit_substitute_library to apply edit commands from
    # one library to another library. For example, set to "*" to
    # make all edit commands use a wildcard for the library name.

    global fm_edit_substitute_library
    #    set fm_edit_substitute_library "*"
}




#
# Don't change anything below this line
#


proc generic_show_warning { msg } {
    global fm_edit_enable_warnings
    if { $fm_edit_enable_warnings } {
        puts "# $msg"
    }
}


if { $synopsys_program_name eq "fm_shell" } {

    proc fm_internal_abs_path { PARTS } {
        # This function is only called for a design or a lib cell

        # Strip tag
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 0]

        # Replace container
        global fm_edit_substitute_container
        if { [info exists fm_edit_substitute_container] } {
            set PARTS [lreplace $PARTS 0 0 $fm_edit_substitute_container]
        }

        # Add colon to container name
        set PARTS [lreplace $PARTS 0 0 "[lindex $PARTS 0]:"]

        # Echo command
        global fm_edit_echo_commands
        if { [info exists fm_edit_echo_commands] && $fm_edit_echo_commands == 1 } {
            set NAME [join $PARTS "/"]
            return $NAME
        }

        # Loop over libraries
        foreach LIB [split [lindex $PARTS 1] ","] {

            # PARTS with just one library at a time
            set NEWPARTS [lreplace $PARTS 1 1 $LIB]

            # Edit vs non-edit libraries
            if { $TAG eq "DESIGN" } {
                global fm_edit_use_edit_libraries
                if { [info exists fm_edit_use_edit_libraries] && $fm_edit_use_edit_libraries == 1 } {
                    regsub -all {^FM_EDIT_} $LIB {} LIB
                    set NEWPARTS [lreplace $NEWPARTS 1 1 $LIB]
                    set NAME [join $NEWPARTS "/"]

                    set DES_CLCT [get_designs -quiet -exact $NAME]
                    if { [sizeof_collection $DES_CLCT] == 0 } {
                        # Design not found
                        continue
                    }
                    
                    edit_design $NAME
                    set LIB "FM_EDIT_$LIB"
                } else {
                    regsub -all {^FM_EDIT_} $LIB {} LIB
                }
                set NEWPARTS [lreplace $NEWPARTS 1 1 $LIB]
            }

            # Concat with slashes
            set NAME [join $NEWPARTS "/"]

            if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
                set LC_CLCT [get_lib_cells -quiet -exact $NAME]
                if { [sizeof_collection $LC_CLCT] == 1 } {
                    return $LC_CLCT
                }
            }

            if { $TAG eq "DESIGN" || $TAG eq "NEWDESIGN" } {
                set DES_CLCT [get_designs -quiet -exact $NAME]
                if { [sizeof_collection $DES_CLCT] == 1 } {
                    return $DES_CLCT
                }
            }
        }
        
        if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
            set NEWPARTS [lreplace $PARTS 1 1 "*"];
            set NAME [join $NEWPARTS "/"];
            set LC_CLCT [get_lib_cells -quiet -exact $NAME];
            if { [sizeof_collection $LC_CLCT] == 1 } {
                return $LC_CLCT;
            }
            if { [sizeof_collection $LC_CLCT] > 1 } {
                puts "ERROR: Cannot find cell within given list of libraries. Attempt to search all libraries resulted in several matches: $NAME"
            }
        }

        puts "ERROR: Cannot find design or library cell: $PARTS"

        if { $TAG eq "NEWDESIGN" || $TAG eq "NEWTECH" } {
            puts "INFO: Design or library cell was read into Formality using 'read_verilog -extra_library_cells': $PARTS"
        }

        return -code error
    }

    proc fm_internal_rel_path { PARTS } {
        # This function is only called for a net, a cell, a pin, or a port.
        # The current_design has already been set.

        # Strip tag
        set NAME [lreplace $PARTS 0 0]

        # Concat with slashes
        set NAME [join $NAME "/"]

        global fm_edit_echo_commands
        if { [info exists fm_edit_echo_commands] && $fm_edit_echo_commands == 1 } {
            return $NAME
        }

        set TYPE [lindex $PARTS 0]
        if { $TYPE eq "NET" || $TYPE eq "NET0" || $TYPE eq "NET1" } {
            set GETTYPE "nets"
        } elseif { $TYPE eq "CELL" } {
            set GETTYPE "cells"
        } elseif { $TYPE eq "PIN" } {
            set GETTYPE "pins"
        } elseif { $TYPE eq "PORT" } {
            set GETTYPE "ports"
        } else {
            puts "ERROR: Unknown type $TYPE in: $PARTS"
            return -code error
        }

        set CLCT [get_$GETTYPE -quiet -exact $NAME]

        if { [sizeof_collection $CLCT] == 1 } {
            return $CLCT
        }

        # Object doesn't exist, so maybe we are about to create it
        return $NAME
    }

    proc fm_internal_edit_cmd { arg } {
        global fm_edit_echo_commands
        if { [info exists fm_edit_echo_commands] && $fm_edit_echo_commands == 1 } {
            if { [lindex $arg 0] eq "current_design" } {
                global fm_internal_last_design
                if { ![info exists fm_internal_last_design] } { set fm_internal_last_design "" }
                set LASTDESIGN [lindex $arg 1]
                if { $LASTDESIGN eq $fm_internal_last_design } { return }
                set fm_internal_last_design $LASTDESIGN
            }
            puts "$arg"
        } else {
            uplevel #0 $arg
        }
    }

    proc generic_create_design { DESIGN1 INSTS DESIGN2 } {
        set DESIGN1 [fm_internal_abs_path $DESIGN1]
        fm_internal_edit_cmd [list current_design $DESIGN1]
        fm_internal_edit_cmd [list create_design $DESIGN2]
        return
    }

    proc generic_create_net { DESIGN INSTS NET {OPTS ""} } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        set NET [fm_internal_rel_path $NET]
        if { $OPTS eq "" } {
            fm_internal_edit_cmd [list create_net $NET]
        } else {
            fm_internal_edit_cmd [list create_net $NET -$OPTS]
        }
        return
    }

    proc generic_remove_net { DESIGN INSTS NET_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        if { $NET_OR_OPTS eq "all" } {
            fm_internal_edit_cmd [list remove_net -all]
        } else {
            set NET [fm_internal_rel_path $NET_OR_OPTS]
            fm_internal_edit_cmd [list remove_net $NET]
        }
        return
    }

    proc generic_create_cell { DESIGN1 INSTS CELL DESIGN2 } {
        # In DESIGN1, create CELL of DESIGN2
        set DESIGN1 [fm_internal_abs_path $DESIGN1]
        set DESIGN2 [fm_internal_abs_path $DESIGN2]
        fm_internal_edit_cmd [list current_design $DESIGN1]
        set CELL [fm_internal_rel_path $CELL]
        fm_internal_edit_cmd [list create_cell $CELL $DESIGN2]
        return
    }

    proc generic_remove_cell { DESIGN INSTS CELL_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        if { $CELL_OR_OPTS eq "all" } {
            fm_internal_edit_cmd [list remove_cell -all]
        } else {
            set CELL [fm_internal_rel_path $CELL_OR_OPTS]
            fm_internal_edit_cmd [list remove_cell $CELL]
        }
        return
    }
    
    proc generic_create_port { DESIGN INSTS PORT DIR } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        set PORT [fm_internal_rel_path $PORT]
        fm_internal_edit_cmd [list create_port $PORT -direction $DIR]
        return
    }

    proc generic_remove_port { DESIGN INSTS PORT_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        if { $PORT_OR_OPTS eq "all" } {
            fm_internal_edit_cmd [list remove_port -all]
        } else {
            set PORT [fm_internal_rel_path $PORT_OR_OPTS]
            fm_internal_edit_cmd [list remove_port $PORT]
        }
        return
    }

    proc generic_connect_net { DESIGN INSTS NET PIN } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        set NET [fm_internal_rel_path $NET]
        set PIN [fm_internal_rel_path $PIN]
        fm_internal_edit_cmd [list connect_net $NET $PIN]
        return
    }

    proc generic_disconnect_net { DESIGN INSTS NET PIN_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        set NET [fm_internal_rel_path $NET]
        if { $PIN_OR_OPTS eq "all" } {
            fm_internal_edit_cmd [list disconnect_net $NET -all]
        } else {
            set PIN [fm_internal_rel_path $PIN_OR_OPTS]
            fm_internal_edit_cmd [list disconnect_net $NET $PIN]
        }
        return
    }

    proc generic_change_link { DESIGN1 INSTS CELL DESIGN2 {OPTS ""} } {
        # In DESIGN1, change CELL's design to DESIGN2
        set DESIGN1 [fm_internal_abs_path $DESIGN1]
        set DESIGN2 [fm_internal_abs_path $DESIGN2]
        fm_internal_edit_cmd [list current_design $DESIGN1]
        set CELL [fm_internal_rel_path $CELL]
        if { $OPTS eq "force" } {
            fm_internal_edit_cmd [list change_link -force $CELL $DESIGN2]
        } else {
            fm_internal_edit_cmd [list change_link $CELL $DESIGN2]
        }
        return
    }

    proc generic_create_primitive { DESIGN INSTS CELL OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        set CELL [fm_internal_rel_path $CELL]
        set TYPE [lindex $OPTS 0]
        set SIZE [lindex $OPTS 1]
        fm_internal_edit_cmd [list create_primitive $CELL $TYPE -size $SIZE]
        return
    }

    proc generic_invert_pin { DESIGN INSTS PIN } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        fm_internal_edit_cmd [list current_design $DESIGN]
        set PIN [fm_internal_rel_path $PIN]
        fm_internal_edit_cmd [list invert_pin $PIN]
        return
    }
}

if { $synopsys_program_name eq "dc_shell" } {

    proc fm_internal_abs_path { PARTS } {
        # This function is only called for a design or a lib cell

        # Strip tag and container
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 1]

        set DESIGN [lindex $PARTS 1]

        # Formality may have created #PWR or #UPF versions, so we need
        # to strip the names of those endings
        regsub -all {#PWR$} $DESIGN {} DESIGN
        regsub -all {#UPF$} $DESIGN {} DESIGN

        global fm_edit_substitute_library
        if { [info exists fm_edit_substitute_library] } {
            set LIBCELL $fm_edit_substitute_library
        } else {
            set LIBCELL [lindex $PARTS 0]
        }
        regsub -all {^FM_EDIT_} $LIBCELL {} LIBCELL

        foreach LIBCELL [split $LIBCELL ","] {
            set LIBCELL $LIBCELL/$DESIGN

            if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
                set LC_CLCT [get_lib_cells -quiet $LIBCELL]
                if { [sizeof_collection $LC_CLCT] == 1 } {
                    return $LC_CLCT
                }
            }

            if { $TAG eq "DESIGN" || $TAG eq "NEWDESIGN" } {
                set DES_CLCT [get_designs -quiet -exact $DESIGN]
                if { [sizeof_collection $DES_CLCT] == 1 } {
                    return $DES_CLCT
                }
            }
        }

        if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
            set ALL_LIB_CELL "*/$DESIGN";
            set LC_CLCT [get_lib_cells -quiet $ALL_LIB_CELL];
            if { [sizeof_collection $LC_CLCT] == 1 } {
                return $LC_CLCT;
            }
            if { [sizeof_collection $LC_CLCT] > 1 } {
                puts "ERROR: Cannot find cell within given list of libraries. Attempt to search all libraries resulted in several matches: $ALL_LIB_CELL";
            }
        }

        puts "ERROR: Cannot find design or library cell: $PARTS"

        if { $TAG eq "NEWDESIGN" || $TAG eq "NEWTECH" } {
            puts "INFO: Design or library cell was read into Formality using 'read_verilog -extra_library_cells': $PARTS"
        }

        return -code error
    }

    proc fm_internal_rel_path { PARTS } {
        # This function is only called for a net, a cell, a pin, or a port.
        # The current_design has already been set.

        # Strip tag
        set NAME [lreplace $PARTS 0 0]

        # Concat with slashes
        set NAME [join $NAME "/"]

        set TYPE [lindex $PARTS 0]
        if { $TYPE eq "NET" || $TYPE eq "NET0" || $TYPE eq "NET1" } {
            set CLCT [get_nets -quiet -exact $NAME]
        } elseif { $TYPE eq "CELL" } {
            set CLCT [get_cells -quiet -exact $NAME]
        } elseif { $TYPE eq "PIN" } {
            set CLCT [get_pins -quiet -exact $NAME]
        } elseif { $TYPE eq "PORT" } {
            set CLCT [get_ports -quiet -exact $NAME]
        } else {
            puts "ERROR: Unknown type $TYPE in: $PARTS"
            return -code error
        }

        if { [sizeof_collection $CLCT] == 1 } {
            return $CLCT
        }

        # Object doesn't exist, so maybe we are about to create it
        return $NAME
    }

    proc generic_create_design { DESIGN1 INSTS DESIGN2 } {
        create_design $DESIGN2
        return
    }

    proc generic_create_net { DESIGN INSTS NET {OPTS ""} } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        current_design $DESIGN
        set NET [fm_internal_rel_path $NET]
        if { $OPTS eq "" } {
            create_net $NET
        } elseif { $OPTS eq "power" || $OPTS eq "tie_high" }  {
            create_net $NET -tie_high
        } elseif { $OPTS eq "ground" || $OPTS eq "tie_low" }  {
            create_net $NET -tie_low
        } else {
            return -code error
        }
        return
    }

    proc generic_remove_net { DESIGN INSTS NET_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        current_design $DESIGN
        if { $NET_OR_OPTS eq "all" } {
            remove_net -all
        } else {
            set NET [fm_internal_rel_path $NET_OR_OPTS]
            remove_net $NET
        }
        return
    }

    proc generic_create_cell { DESIGN1 INSTS CELL DESIGN2 } {
        # In DESIGN1, create CELL of DESIGN2
        set DESIGN1 [fm_internal_abs_path $DESIGN1]
        set DESIGN2 [fm_internal_abs_path $DESIGN2]
        current_design $DESIGN1
        set CELL [fm_internal_rel_path $CELL]
        create_cell $CELL $DESIGN2
        return
    }

    proc generic_remove_cell { DESIGN INSTS CELL_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        current_design $DESIGN
        if { $CELL_OR_OPTS eq "all" } {
            remove_cell -all
        } else {
            set CELL [fm_internal_rel_path $CELL_OR_OPTS]
            remove_cell $CELL
        }
        return
    }
    
    proc generic_create_port { DESIGN INSTS PORT DIR } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        current_design $DESIGN
        set PORT [fm_internal_rel_path $PORT]
        create_port $PORT -direction $DIR
        return
    }

    proc generic_remove_port { DESIGN INSTS PORT_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        current_design $DESIGN
        if { $PORT_OR_OPTS eq "all" } {
            remove_port -all
        } else {
            set PORT [fm_internal_rel_path $PORT_OR_OPTS]
            remove_port $PORT
        }
        return
    }

    proc generic_connect_net { DESIGN INSTS NET PIN } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        current_design $DESIGN
        set NETNAME [fm_internal_rel_path $NET]
        set PIN [fm_internal_rel_path $PIN]
        set NETTYPE [lindex $NET 0]
        if { $NETTYPE ne "NET" } {
            # Constant 0/1 net
            set FIND [get_nets -quiet $NETNAME]
            if { [sizeof_collection $FIND] == 0 } {
                # Cannot find the constant net, so let's create it
                if { $NETTYPE eq "NET0" } {
                    create_net $NETNAME -ground
                } else {
                    create_net $NETNAME -power
                }
            }
        }
        if { [sizeof_collection [get_nets -quiet $NETNAME]] == 0 } {
            # Couldn't find the net, but can we find a port with that name?
            set PORT [get_ports -quiet $NETNAME]
            if { [sizeof_collection $PORT] == 1 } {
                # Yes. Create a new net and connect it to the port
                generic_show_warning "WARNING: Cannot find net $NETNAME. We will create it and connect it to the port by the same name."
                create_net $NETNAME
                connect_net $NETNAME $PORT
            }
        }
        connect_net $NETNAME $PIN
        return
    }

    proc generic_disconnect_net { DESIGN INSTS NET PIN_OR_OPTS } {
        set DESIGN [fm_internal_abs_path $DESIGN]
        current_design $DESIGN
        set NETNAME [fm_internal_rel_path $NET]
        set NETTYPE [lindex $NET 0]
        if { $PIN_OR_OPTS eq "all" } {
            if { $NETTYPE ne "NET" } {
                # Constant 0/1 net
                set FIND [get_nets -quiet $NETNAME]
                if { [sizeof_collection $FIND] == 0 } {
                    # Cannot find the constant net
                    generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Ignoring the disconnect_net command."
                    return
                }
            }
            disconnect_net $NETNAME -all
        } else {
            set PIN [fm_internal_rel_path $PIN_OR_OPTS]
            if { $NETTYPE ne "NET" } {
                # Constant 0/1 net
                set FIND [get_nets -quiet $NETNAME]
                if { [sizeof_collection $FIND] == 0 } {
                    # Cannot find the constant net.
                    set PINNAME [get_attribute $PIN full_name]
                    generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Using the net connected to $PINNAME instead."
                    if { [get_attribute $PIN object_class] == "pin" } {
                        set NETNAME [get_nets -quiet -of_objects $PIN -boundary_type upper]
                    } else {
                        # The pin is actually a port
                        set NETNAME [get_nets -quiet -of_objects $PIN -boundary_type lower]
                    }
                    if { $NETNAME == "" } {
                        set NETNAME [get_nets -quiet -of_objects $PIN]
                    }
                }
            }
            disconnect_net $NETNAME $PIN
        }
        return
    }

    proc generic_change_link { DESIGN1 INSTS CELL DESIGN2 {OPTS ""} } {
        # In DESIGN1, change CELL's design to DESIGN2
        set DESIGN1 [fm_internal_abs_path $DESIGN1]
        set DESIGN2 [get_object_name [fm_internal_abs_path $DESIGN2]]
        current_design $DESIGN1
        set CELL [fm_internal_rel_path $CELL]
        if { $OPTS eq "force" } {
            change_link -force $CELL $DESIGN2
        } else {
            change_link $CELL $DESIGN2
        }
        return
    }

    proc generic_create_primitive { DESIGN INSTS CELL OPTS } {
        generic_show_warning "WARNING: The create_primitive command is not available and will be ignored."
        return
    }

    proc generic_invert_pin { DESIGN INSTS PIN } {
        generic_show_warning "WARNING: The invert_pin command is not available and will be ignored."
        return
    }
}

if { $synopsys_program_name eq "icc_shell" } {

    proc fm_internal_abs_path { PARTS } {
        # This function is only called for a design or a lib cell

        # Strip tag and container
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 1]

        set DESIGN [lindex $PARTS 1]

        # Formality may have created #PWR or #UPF versions, so we need
        # to strip the names of those endings
        regsub -all {#PWR$} $DESIGN {} DESIGN
        regsub -all {#UPF$} $DESIGN {} DESIGN

        global fm_edit_substitute_library
        if { [info exists fm_edit_substitute_library] } {
            set LIBCELL $fm_edit_substitute_library
        } else {
            set LIBCELL [lindex $PARTS 0]
        }
        regsub -all {^FM_EDIT_} $LIBCELL {} LIBCELL

        foreach LIBCELL [split $LIBCELL ","] {
            set LIBCELL $LIBCELL/$DESIGN

            if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
                set LC_CLCT [get_lib_cells -quiet $LIBCELL]
                if { [sizeof_collection $LC_CLCT] == 1 } {
                    return $LC_CLCT
                }
            }

            if { $TAG eq "DESIGN" || $TAG eq "NEWDESIGN" } {
                set DES_CLCT [get_designs -quiet -exact $DESIGN]
                if { [sizeof_collection $DES_CLCT] == 1 } {
                    return $DES_CLCT
                }
            }
        }

        if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
            set ALL_LIB_CELL "*/$DESIGN";
            set LC_CLCT [get_lib_cells -quiet $ALL_LIB_CELL];
            if { [sizeof_collection $LC_CLCT] == 1 } {
                return $LC_CLCT;
            }
            if { [sizeof_collection $LC_CLCT] > 1 } {
                puts "ERROR: Cannot find cell within given list of libraries. Attempt to search all libraries resulted in several matches: $ALL_LIB_CELL";
            }
        }

        puts "ERROR: Cannot find design or library cell: $PARTS"

        if { $TAG eq "NEWDESIGN" || $TAG eq "NEWTECH" } {
            puts "INFO: Design or library cell was read into Formality using 'read_verilog -extra_library_cells': $PARTS"
        }

        return -code error
    }

    proc fm_internal_set_inst_path { PARTS } {
        # This function is only called for an instance path

        # Strip tag, container, and library
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 2]

        global fm_edit_root_path
        if { [info exists fm_edit_root_path] } {
            # Concat with slashes
            set NAME2 [join $PARTS "/"]

            # Remove $fm_edit_root_path prefix
            regsub -all "^$fm_edit_root_path/?" $NAME2 {} NAME
            if { $NAME eq $NAME2 } {
                # Return failure -- prefix not found
                return 0
            }
        } else {
            # Remove top design name
            set PARTS [lreplace $PARTS 0 0]

            # Concat with slashes
            set NAME [join $PARTS "/"]
        }

        # Reset current_instance to the top of the design hierarchy
        redirect /dev/null {current_instance}

        if { $NAME ne "" } {
            current_instance $NAME
        }

        # Return success
        return 1
    }

    proc fm_internal_rel_path { PARTS } {
        # This function is only called for a net, a cell, a pin, or a port.
        # The current_design has already been set.

        # Strip tag
        set NAME [lreplace $PARTS 0 0]

        # Concat with slashes
        set NAME [join $NAME "/"]

        set TYPE [lindex $PARTS 0]
        if { $TYPE eq "NET" || $TYPE eq "NET0" || $TYPE eq "NET1" } {
            set CLCT [get_nets -all -quiet -exact $NAME]
        } elseif { $TYPE eq "CELL" } {
            set CLCT [get_cells -quiet -exact $NAME]
        } elseif { $TYPE eq "PIN" } {
            set CLCT [get_pins -quiet -exact $NAME]
        } elseif { $TYPE eq "PORT" } {
            set CLCT [get_ports -quiet -exact $NAME]
        } else {
            puts "ERROR: Unknown type $TYPE in: $PARTS"
            return -code error
        }

        if { [sizeof_collection $CLCT] == 1 } {
            return $CLCT
        }

        # Object doesn't exist, so maybe we are about to create it
        return $NAME
    }

    proc generic_create_design { DESIGN1 INSTS DESIGN2 } {
        generic_show_warning "WARNING: The create_design command is not available and will be ignored."
        return
    }

    proc generic_create_net { DESIGN INSTS NET {OPTS ""} } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NET [fm_internal_rel_path $NET]
                if { $OPTS eq "" } {
                    create_net $NET
                } else {
                    create_net $NET -$OPTS
                }
            }
        }
        return
    }

    proc generic_remove_net { DESIGN INSTS NET_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $NET_OR_OPTS eq "all" } {
                    remove_net -all
                } else {
                    set NET [fm_internal_rel_path $NET_OR_OPTS]
                    remove_net $NET
                }
            }
        }
        return
    }

    proc generic_create_cell { DESIGN1 INSTS CELL DESIGN2 } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                # In INST, create CELL of DESIGN2
                set DESIGN2 [fm_internal_abs_path $DESIGN2]
                set CELL [fm_internal_rel_path $CELL]
                create_cell $CELL $DESIGN2
             }
        }
        return
    }

    proc generic_remove_cell { DESIGN INSTS CELL_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $CELL_OR_OPTS eq "all" } {
                    remove_cell -all
                } else {
                    set CELL [fm_internal_rel_path $CELL_OR_OPTS]
                    remove_cell $CELL
                }
            }
        }
        return
    }
    
    proc generic_create_port { DESIGN INSTS PORT DIR } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set PORT [fm_internal_rel_path $PORT]
                create_port $PORT -direction $DIR
            }
        }
        return
    }

    proc generic_remove_port { DESIGN INSTS PORT_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $PORT_OR_OPTS eq "all" } {
                    remove_port -all
                } else {
                    set PORT [fm_internal_rel_path $PORT_OR_OPTS]
                    redirect -variable REPORT {set RES [report_bus $PORT]}
                    if { $RES } {
                        puts "INFO: Port [get_object_name $PORT] is part of a bus. Removing bus so port can be removed."
                        set BUS [lindex [lindex [split $REPORT '\n'] 4] 0]
                        undefine_bus -type port -name $BUS
                    }
                    remove_port $PORT
                }
            }
        }
        return
    }

    proc generic_connect_net { DESIGN INSTS NET PIN } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NETNAME [fm_internal_rel_path $NET]
                set PIN [fm_internal_rel_path $PIN]
                set NETTYPE [lindex $NET 0]
                if { $NETTYPE ne "NET" } {
                    # Constant 0/1 net
                    set FIND [get_nets -all -quiet $NETNAME]
                    if { [sizeof_collection $FIND] == 0 } {
                        # Cannot find the constant net, so let's create it
                        if { $NETTYPE eq "NET0" } {
                            create_net $NETNAME -ground
                        } else {
                            create_net $NETNAME -power
                        }
                    }
                }
                connect_net $NETNAME $PIN
            }
        }
        return
    }

    proc generic_disconnect_net { DESIGN INSTS NET PIN_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NETNAME [fm_internal_rel_path $NET]
                set NETTYPE [lindex $NET 0]
                if { $PIN_OR_OPTS eq "all" } {
                    if { $NETTYPE ne "NET" } {
                        # Constant 0/1 net
                        set FIND [get_nets -all -quiet $NETNAME]
                        if { [sizeof_collection $FIND] == 0 } {
                            # Cannot find the constant net
                            generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Ignoring the disconnect_net command."
                            return
                        }
                    }
                    disconnect_net $NETNAME -all
                } else {
                    set PIN [fm_internal_rel_path $PIN_OR_OPTS]
                    if { $NETTYPE ne "NET" } {
                        # Constant 0/1 net
                        set FIND [get_nets -all -quiet $NETNAME]
                        if { [sizeof_collection $FIND] == 0 } {
                            # Cannot find the constant net.
                            set PINNAME [get_attribute $PIN full_name]
                            generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Using the net connected to $PINNAME instead."
                            set NETNAME [all_connected $PIN]
                        }
                    }
                    disconnect_net $NETNAME $PIN
                }
            }
        }
        return
    }

    proc generic_change_link { DESIGN1 INSTS CELL DESIGN2 {OPTS ""} } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                # In INST, change CELL's design to DESIGN2
                set DESIGN2 [get_object_name [fm_internal_abs_path $DESIGN2]]
                set CELL [fm_internal_rel_path $CELL]
                if { $OPTS eq "force" } {
                    change_link -force $CELL $DESIGN2
                } else {
                    change_link $CELL $DESIGN2
                }
            }
        }        
        return
    }

    proc generic_create_primitive { DESIGN INSTS CELL OPTS } {
        generic_show_warning "WARNING: The create_primitive command is not available and will be ignored."
        return
    }

    proc generic_invert_pin { DESIGN INSTS PIN } {
        generic_show_warning "WARNING: The invert_pin command is not available and will be ignored."
        return
    }
}

if { $synopsys_program_name eq "icc2_shell" } {

    proc fm_internal_abs_path { PARTS } {
        # This function is only called for a design or a lib cell

        # Strip tag and container
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 1]

        set DESIGN [lindex $PARTS 1]

        # Formality may have created #PWR or #UPF versions, so we need
        # to strip the names of those endings
        regsub -all {#PWR$} $DESIGN {} DESIGN
        regsub -all {#UPF$} $DESIGN {} DESIGN

        global fm_edit_substitute_library
        if { [info exists fm_edit_substitute_library] } {
            set LIBCELL $fm_edit_substitute_library
        } else {
            set LIBCELL [lindex $PARTS 0]
        }
        regsub -all {^FM_EDIT_} $LIBCELL {} LIBCELL

        foreach LIBCELL [split $LIBCELL ","] {
            set LIBCELL $LIBCELL/$DESIGN

            if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
                set LC_CLCT [get_lib_cells -quiet $LIBCELL]
                if { [sizeof_collection $LC_CLCT] == 1 } {
                    return $LC_CLCT
                }
            }

            if { $TAG eq "DESIGN" || $TAG eq "NEWDESIGN" } {
                set DES_CLCT [get_designs -quiet -exact $DESIGN]
                if { [sizeof_collection $DES_CLCT] == 1 } {
                    return $DES_CLCT
                }
            }
        }

        if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
            set ALL_LIB_CELL "*/$DESIGN";
            set LC_CLCT [get_lib_cells -quiet $ALL_LIB_CELL];
            if { [sizeof_collection $LC_CLCT] == 1 } {
                return $LC_CLCT;
            }
            if { [sizeof_collection $LC_CLCT] > 1 } {
                puts "ERROR: Cannot find cell within given list of libraries. Attempt to search all libraries resulted in several matches: $ALL_LIB_CELL";
            }
        }

        puts "ERROR: Cannot find design or library cell: $PARTS"

        if { $TAG eq "NEWDESIGN" || $TAG eq "NEWTECH" } {
            puts "INFO: Design or library cell was read into Formality using 'read_verilog -extra_library_cells': $PARTS"
        }

        return -code error
    }

    proc fm_internal_set_inst_path { PARTS } {
        # This function is only called for an instance path

        # Strip tag, container, and library
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 2]

        global fm_edit_root_path
        if { [info exists fm_edit_root_path] } {
            # Concat with slashes
            set NAME2 [join $PARTS "/"]

            # Remove $fm_edit_root_path prefix
            regsub -all "^$fm_edit_root_path/?" $NAME2 {} NAME
            if { $NAME eq $NAME2 } {
                # Return failure -- prefix not found
                return 0
            }
        } else {
            # Remove top design name
            set PARTS [lreplace $PARTS 0 0]

            # Concat with slashes
            set NAME [join $PARTS "/"]
        }

        # Reset current_instance to the top of the design hierarchy
        redirect /dev/null {current_instance}

        if { $NAME ne "" } {
            current_instance $NAME
        }

        # Return success
        return 1
    }

    proc fm_internal_rel_path { PARTS } {
        # This function is only called for a net, a cell, a pin, or a port.
        # The current_design has already been set.

        # Strip tag
        set NAME [lreplace $PARTS 0 0]

        # Concat with slashes
        set NAME [join $NAME "/"]

        set TYPE [lindex $PARTS 0]
        if { $TYPE eq "NET" || $TYPE eq "NET0" || $TYPE eq "NET1" } {
            set CLCT [get_nets -quiet -exact $NAME]
        } elseif { $TYPE eq "CELL" } {
            set CLCT [get_cells -quiet -exact $NAME]
        } elseif { $TYPE eq "PIN" } {
            set CLCT [get_pins -quiet -exact $NAME]
        } elseif { $TYPE eq "PORT" } {
            set CLCT [get_ports -quiet -exact $NAME]
        } else {
            puts "ERROR: Unknown type $TYPE in: $PARTS"
            return -code error
        }

        if { [sizeof_collection $CLCT] == 1 } {
            return $CLCT
        }

        # Object doesn't exist, so maybe we are about to create it
        return $NAME
    }

    proc generic_create_design { DESIGN1 INSTS DESIGN2 } {
        create_module $DESIGN2
        return
    }

    proc generic_create_net { DESIGN INSTS NET {OPTS ""} } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NET [fm_internal_rel_path $NET]
                if { $OPTS eq "" } {
                    create_net $NET
                } else {
                    create_net $NET -$OPTS
                }
            }
        }
        return
    }

    proc generic_remove_net { DESIGN INSTS NET_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $NET_OR_OPTS eq "all" } {
                    remove_net -all
                } else {
                    set NET [fm_internal_rel_path $NET_OR_OPTS]
                    remove_net $NET
                }
            }
        }
        return
    }

    proc generic_create_cell { DESIGN1 INSTS CELL DESIGN2 } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                # In INST, create CELL of DESIGN2
                set DESIGN2 [fm_internal_abs_path $DESIGN2]
                set CELL [fm_internal_rel_path $CELL]
                create_cell $CELL $DESIGN2
             }
        }
        return
    }

    proc generic_remove_cell { DESIGN INSTS CELL_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $CELL_OR_OPTS eq "all" } {
                    remove_cell -all
                } else {
                    set CELL [fm_internal_rel_path $CELL_OR_OPTS]
                    remove_cell $CELL
                }
            }
        }
        return
    }
    
    proc generic_create_port { DESIGN INSTS PORT DIR } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set PORT [fm_internal_rel_path $PORT]
                create_port $PORT -direction $DIR
            }
        }
        return
    }

    proc generic_remove_port { DESIGN INSTS PORT_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $PORT_OR_OPTS eq "all" } {
                    remove_port -all
                } else {
                    set PORT [fm_internal_rel_path $PORT_OR_OPTS]
                    remove_port $PORT
                }
            }
        }
        return
    }

    proc generic_connect_net { DESIGN INSTS NET PIN } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NETNAME [fm_internal_rel_path $NET]
                set PIN [fm_internal_rel_path $PIN]
                set NETTYPE [lindex $NET 0]
                if { $NETTYPE ne "NET" } {
                    # Constant 0/1 net
                    set FIND [get_nets -quiet $NETNAME]
                    if { [sizeof_collection $FIND] == 0 } {
                        # Cannot find the constant net, so let's create it
                        if { $NETTYPE eq "NET0" } {
                            create_net $NETNAME -ground
                        } else {
                            create_net $NETNAME -power
                        }
                    }
                }
                connect_net $NETNAME $PIN
            }
        }
        return
    }

    proc generic_disconnect_net { DESIGN INSTS NET PIN_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NETNAME [fm_internal_rel_path $NET]
                set NETTYPE [lindex $NET 0]
                if { $PIN_OR_OPTS eq "all" } {
                    if { $NETTYPE ne "NET" } {
                        # Constant 0/1 net
                        set FIND [get_nets -quiet $NETNAME]
                        if { [sizeof_collection $FIND] == 0 } {
                            # Cannot find the constant net
                            generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Ignoring the disconnect_net command."
                            return
                        }
                    }
                    disconnect_net $NETNAME -all
                } else {
                    set PIN [fm_internal_rel_path $PIN_OR_OPTS]
                    if { $NETTYPE ne "NET" } {
                        # Constant 0/1 net
                        set FIND [get_nets -quiet $NETNAME]
                        if { [sizeof_collection $FIND] == 0 } {
                            # Cannot find the constant net.
                            set PINNAME [get_attribute $PIN full_name]
                            generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Using the net connected to $PINNAME instead."
                            if { [get_attribute $PIN object_class] == "pin" } {
                                set NETNAME [get_nets -quiet -of_objects $PIN -boundary_type upper]
                            } else {
                                # The pin is actually a port
                                set NETNAME [get_nets -quiet -of_objects $PIN -boundary_type lower]
                            }    
                            if { $NETNAME == "" } {
                                set NETNAME [get_nets -quiet -of_objects $PIN]
                            }
                        }
                    }
                    disconnect_net $NETNAME $PIN
                }
            }
        }
        return
    }

    proc generic_change_link { DESIGN1 INSTS CELL DESIGN2 {OPTS ""} } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                # In INST, change CELL's design to DESIGN2
                set DESIGN2 [get_object_name [fm_internal_abs_path $DESIGN2]]
                set CELL [fm_internal_rel_path $CELL]
                if { $OPTS eq "force" } {
                    change_link -force $CELL $DESIGN2
                } else {
                    change_link $CELL $DESIGN2
                }
            }
        }        
        return
    }

    proc generic_create_primitive { DESIGN INSTS CELL OPTS } {
        generic_show_warning "WARNING: The create_primitive command is not available and will be ignored."
        return
    }

    proc generic_invert_pin { DESIGN INSTS PIN } {
        generic_show_warning "WARNING: The invert_pin command is not available and will be ignored."
        return
    }
}

if { $synopsys_program_name eq "fc_shell" } {

    proc fm_internal_abs_path { PARTS } {
        # This function is only called for a design or a lib cell

        # Strip tag and container
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 1]

        set DESIGN [lindex $PARTS 1]

        # Formality may have created #PWR or #UPF versions, so we need
        # to strip the names of those endings
        regsub -all {#PWR$} $DESIGN {} DESIGN
        regsub -all {#UPF$} $DESIGN {} DESIGN

        global fm_edit_substitute_library
        if { [info exists fm_edit_substitute_library] } {
            set LIBCELL $fm_edit_substitute_library
        } else {
            set LIBCELL [lindex $PARTS 0]
        }
        regsub -all {^FM_EDIT_} $LIBCELL {} LIBCELL

        foreach LIBCELL [split $LIBCELL ","] {
            set LIBCELL $LIBCELL/$DESIGN

            if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
                set LC_CLCT [get_lib_cells -quiet $LIBCELL]
                if { [sizeof_collection $LC_CLCT] == 1 } {
                    return $LC_CLCT
                }
            }

            if { $TAG eq "DESIGN" || $TAG eq "NEWDESIGN" } {
                set DES_CLCT [get_modules -quiet -exact $DESIGN]
                if { [sizeof_collection $DES_CLCT] == 1 } {
                    return $DES_CLCT
                } 
            }
        }

        if { $TAG eq "TECH" || $TAG eq "NEWTECH" } {
            set ALL_LIB_CELL "*/$DESIGN";
            set LC_CLCT [get_lib_cells -quiet $ALL_LIB_CELL];
            if { [sizeof_collection $LC_CLCT] == 1 } {
                return $LC_CLCT;
            }
            if { [sizeof_collection $LC_CLCT] > 1 } {
                puts "ERROR: Cannot find cell within given list of libraries. Attempt to search all libraries resulted in several matches: $ALL_LIB_CELL";
            }
        }

        puts "ERROR: Cannot find design or library cell: $PARTS"

        if { $TAG eq "NEWDESIGN" || $TAG eq "NEWTECH" } {
            puts "INFO: Design or library cell was read into Formality using 'read_verilog -extra_library_cells': $PARTS"
        }

        return -code error
    }

    proc fm_internal_set_inst_path { PARTS } {
        # This function is only called for an instance path

        # Strip tag, container, and library
        set TAG [lindex $PARTS 0]
        set PARTS [lreplace $PARTS 0 2]

        global fm_edit_root_path
        if { [info exists fm_edit_root_path] } {
            # Concat with slashes
            set NAME2 [join $PARTS "/"]

            # Remove $fm_edit_root_path prefix
            regsub -all "^$fm_edit_root_path/?" $NAME2 {} NAME
            if { $NAME eq $NAME2 } {
                # Return failure -- prefix not found
                return 0
            }
        } else {
            # Remove top design name
            set PARTS [lreplace $PARTS 0 0]

            # Concat with slashes
            set NAME [join $PARTS "/"]
        }

        # Reset current_instance to the top of the design hierarchy
        redirect /dev/null {current_instance}

        if { $NAME ne "" } {
            current_instance $NAME
        }

        # Return success
        return 1
    }

    proc fm_internal_rel_path { PARTS } {
        # This function is only called for a net, a cell, a pin, or a port.
        # The current_design has already been set.

        # Strip tag
        set NAME [lreplace $PARTS 0 0]

        # Concat with slashes
        set NAME [join $NAME "/"]

        set TYPE [lindex $PARTS 0]
        if { $TYPE eq "NET" || $TYPE eq "NET0" || $TYPE eq "NET1" } {
            set CLCT [get_nets -quiet -exact $NAME]
        } elseif { $TYPE eq "CELL" } {
            set CLCT [get_cells -quiet -exact $NAME]
        } elseif { $TYPE eq "PIN" } {
            set CLCT [get_pins -quiet -exact $NAME]
        } elseif { $TYPE eq "PORT" } {
            set CLCT [get_ports -quiet -exact $NAME]
        } else {
            puts "ERROR: Unknown type $TYPE in: $PARTS"
            return -code error
        }

        if { [sizeof_collection $CLCT] == 1 } {
            return $CLCT
        }

        # Object doesn't exist, so maybe we are about to create it
        return $NAME
    }

    proc generic_create_design { DESIGN1 INSTS DESIGN2 } {
        create_module $DESIGN2
        return
    }

    proc generic_create_net { DESIGN INSTS NET {OPTS ""} } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NET [fm_internal_rel_path $NET]
                if { $OPTS eq "" } {
                    create_net $NET
                } else {
                    create_net $NET -$OPTS
                }
            }
        }
        return
    }

    proc generic_remove_net { DESIGN INSTS NET_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $NET_OR_OPTS eq "all" } {
                    remove_net -all
                } else {
                    set NET [fm_internal_rel_path $NET_OR_OPTS]
                    remove_net $NET
                }
            }
        }
        return
    }

    proc generic_create_cell { DESIGN1 INSTS CELL DESIGN2 } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                # In INST, create CELL of DESIGN2
                set DESIGN2 [fm_internal_abs_path $DESIGN2]
                set CELL [fm_internal_rel_path $CELL]
                create_cell $CELL $DESIGN2
             }
        }
        return
    }

    proc generic_remove_cell { DESIGN INSTS CELL_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $CELL_OR_OPTS eq "all" } {
                    remove_cell -all
                } else {
                    set CELL [fm_internal_rel_path $CELL_OR_OPTS]
                    remove_cell $CELL
                }
            }
        }
        return
    }
    
    proc generic_create_port { DESIGN INSTS PORT DIR } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set PORT [fm_internal_rel_path $PORT]
                create_port $PORT -direction $DIR
            }
        }
        return
    }

    proc generic_remove_port { DESIGN INSTS PORT_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                if { $PORT_OR_OPTS eq "all" } {
                    remove_port -all
                } else {
                    set PORT [fm_internal_rel_path $PORT_OR_OPTS]
                    remove_port $PORT
                }
            }
        }
        return
    }

    proc generic_connect_net { DESIGN INSTS NET PIN } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NETNAME [fm_internal_rel_path $NET]
                set PIN [fm_internal_rel_path $PIN]
                set NETTYPE [lindex $NET 0]
                if { $NETTYPE ne "NET" } {
                    # Constant 0/1 net
                    set FIND [get_nets -quiet $NETNAME]
                    if { [sizeof_collection $FIND] == 0 } {
                        # Cannot find the constant net, so let's create it
                        if { $NETTYPE eq "NET0" } {
                            create_net $NETNAME -ground
                        } else {
                            create_net $NETNAME -power
                        }
                    }
                }
                connect_net $NETNAME $PIN
            }
        }
        return
    }

    proc generic_disconnect_net { DESIGN INSTS NET PIN_OR_OPTS } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                set NETNAME [fm_internal_rel_path $NET]
                set NETTYPE [lindex $NET 0]
                if { $PIN_OR_OPTS eq "all" } {
                    if { $NETTYPE ne "NET" } {
                        # Constant 0/1 net
                        set FIND [get_nets -quiet $NETNAME]
                        if { [sizeof_collection $FIND] == 0 } {
                            # Cannot find the constant net
                            generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Ignoring the disconnect_net command."
                            return
                        }
                    }
                    disconnect_net $NETNAME -all
                } else {
                    set PIN [fm_internal_rel_path $PIN_OR_OPTS]
                    if { $NETTYPE ne "NET" } {
                        # Constant 0/1 net
                        set FIND [get_nets -quiet $NETNAME]
                        if { [sizeof_collection $FIND] == 0 } {
                            # Cannot find the constant net.
                            set PINNAME [get_attribute $PIN full_name]
                            generic_show_warning "WARNING: Cannot find the constant net $NETNAME. Using the net connected to $PINNAME instead."
                            if { [get_attribute $PIN object_class] == "pin" } {
                                set NETNAME [get_nets -quiet -of_objects $PIN -boundary_type upper]
                            } else {
                                # The pin is actually a port
                                set NETNAME [get_nets -quiet -of_objects $PIN -boundary_type lower]
                            }    
                            if { $NETNAME == "" } {
                                set NETNAME [get_nets -quiet -of_objects $PIN]
                            }
                        }
                    }
                    disconnect_net $NETNAME $PIN
                }
            }
        }
        return
    }

    proc generic_change_link { DESIGN1 INSTS CELL DESIGN2 {OPTS ""} } {
        foreach INST $INSTS {
            if { [fm_internal_set_inst_path $INST] } {
                # In INST, change CELL's design to DESIGN2
                set DESIGN2 [get_object_name [fm_internal_abs_path $DESIGN2]]
                set CELL [fm_internal_rel_path $CELL]
                if { $OPTS eq "force" } {
                    change_link -force $CELL $DESIGN2
                } else {
                    change_link $CELL $DESIGN2
                }
            }
        }        
        return
    }

    proc generic_create_primitive { DESIGN INSTS CELL OPTS } {
        generic_show_warning "WARNING: The create_primitive command is not available and will be ignored."
        return
    }

    proc generic_invert_pin { DESIGN INSTS PIN } {
        generic_show_warning "WARNING: The invert_pin command is not available and will be ignored."
        return
    }
}


